(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{482:function(_,e,t){"use strict";t.r(e);var T=t(25),v=Object(T.a)({},(function(){var _=this,e=_.$createElement,t=_._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("ol",[t("li",[_._v("time_wait状态如何产生？**\n由上面的变迁图，首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL值得是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。")])]),_._v(" "),t("p",[t("strong",[_._v("2.time_wait状态产生的原因")])]),_._v(" "),t("p",[t("strong",[_._v("1）为实现TCP全双工连接的可靠释放")])]),_._v(" "),t("p",[_._v("由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。")]),_._v(" "),t("p",[t("strong",[_._v("2）为使旧的数据包在网络因过期而消失")])]),_._v(" "),t("p",[_._v("为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。")]),_._v(" "),t("p",[t("strong",[_._v("3）总结")]),_._v("\n具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。")]),_._v(" "),t("h1",{attrs:{id:"_2、大量time-wait造成的影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、大量time-wait造成的影响"}},[_._v("#")]),_._v(" 2、大量TIME_WAIT造成的影响")]),_._v(" "),t("p",[_._v("在"),t("code",[_._v("高并发短连接的TCP服务器")]),_._v("上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下"),t("code",[_._v("会出现大量socket处于TIME_WAIT状态")]),_._v("。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。")]),_._v(" "),t("p",[_._v("为什么我们要关注这个高并发短连接呢？有两个方面需要注意：")]),_._v(" "),t("ol",[t("li",[t("code",[_._v("高并发")]),_._v("可以让服务器"),t("code",[_._v("在短时间范围内同时占用大量端口")]),_._v("，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。")]),_._v(" "),t("li",[_._v("在这个场景中，短连接表示“"),t("code",[_._v("业务处理+传输数据的时间")]),_._v(" 远远小于 "),t("code",[_._v("TIMEWAIT超时的时间")]),_._v("”的连接。")])]),_._v(" "),t("p",[t("code",[_._v("TCP处于TIMEWAIT状态时，别的请求过来后，没有空闲的端口可供tcp连接，大大影响服务器响应请求。")]),_._v(" 长连接业务的服务就不需要考虑TIMEWAIT状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，"),t("code",[_._v("一般长连接对应的业务的并发量并不会很高")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("3.time_wait状态如何避免")])]),_._v(" "),t("p",[_._v("首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。")])])}),[],!1,null,null,null);e.default=v.exports}}]);