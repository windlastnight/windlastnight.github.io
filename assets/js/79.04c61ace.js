(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{485:function(v,_,t){"use strict";t.r(_);var e=t(25),r=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"进程和线程的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的区别"}},[v._v("#")]),v._v(" "),t("strong",[v._v("进程和线程的区别")])]),v._v(" "),t("p",[t("strong",[v._v("根本区别")]),v._v("：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位")]),v._v(" "),t("p",[t("strong",[v._v("资源开销")]),v._v("：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。")]),v._v(" "),t("p",[t("strong",[v._v("包含关系")]),v._v("：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。")]),v._v(" "),t("p",[t("strong",[v._v("内存分配")]),v._v("：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的")]),v._v(" "),t("p",[t("strong",[v._v("影响关系")]),v._v("：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。")]),v._v(" "),t("p",[t("strong",[v._v("执行过程")]),v._v("：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行")]),v._v(" "),t("p",[t("strong",[v._v("上下文切换")])]),v._v(" "),t("p",[v._v("上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指"),t("strong",[v._v("某一时间点 CPU 寄存器和程序计数器的内容。")])]),v._v(" "),t("ul",[t("li",[v._v("interrupt() // 通知目标线程中断，也就是设置中断标志位")]),v._v(" "),t("li",[v._v("isInterrupted() // 通过检查编中断标志位判断线程是否被中断")]),v._v(" "),t("li",[v._v("interrupted() // 静态方法，判断是否被中断并清楚当前中断状态")])]),v._v(" "),t("h3",{attrs:{id:"interruptedexception"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#interruptedexception"}},[v._v("#")]),v._v(" InterruptedException")]),v._v(" "),t("p",[v._v("通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。")]),v._v(" "),t("h2",{attrs:{id:"等待-wait-和通知-notify"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等待-wait-和通知-notify"}},[v._v("#")]),v._v(" 等待（wait）和通知（notify）")]),v._v(" "),t("p",[v._v("这两个方法是Object类中的，任何对象都可以调用这两个方法。")]),v._v(" "),t("p",[v._v("wait()方法只能在synchronized方法或synchronized块中使用（原因：wait方法会释放锁，只有在syn中才有锁）")]),v._v(" "),t("p",[v._v("notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会")]),v._v(" "),t("p",[v._v("notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。")]),v._v(" "),t("p",[t("strong",[v._v("锁池EntryList")]),v._v("：当一个线程需要调用调用此方法时必须获得该对象的锁，而该对象的锁被其他线程占用，该线程就需要在一个地方等待锁释放，这个地方就是锁池。（"),t("strong",[v._v("排队等待,准备抢锁的池子")]),v._v("）")]),v._v(" "),t("p",[t("strong",[v._v("等待池WaitSet")]),v._v("：调用了wait方法的线程会释放锁并进入等待池，在等待池的线程不会竞争锁。（"),t("strong",[v._v("休息的池子")]),v._v("）")]),v._v(" "),t("p",[v._v("值得注意的是无论是wait方法还是notify方法都需要首先获得目标对象的一个监视锁（monitor lock），得到锁后才可以执行方法。")]),v._v(" "),t("p",[v._v("wait 和 sleep 的区别：")]),v._v(" "),t("p",[v._v("Thread.sleep只会让出CPU ,不会释放任何资源； Object.wait不仅让出CPU , 还会释放已经占有的同步资源锁。")]),v._v(" "),t("h3",{attrs:{id:"线程阻塞工具类-locksupport"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程阻塞工具类-locksupport"}},[v._v("#")]),v._v(" 线程阻塞工具类（LockSupport）")]),v._v(" "),t("p",[v._v("LockSupport 可以在线程内任意位置让线程阻塞，与 suspend 方法相比，弥补了由于 resume 方法发生导致线程无法继续执行的情况，和 wait 方法相比，他不需要获得锁也不会抛出中断异常。")]),v._v(" "),t("p",[v._v("LockSupport 包含静态方法 park 可以阻塞当前线程，unpark 方法可以解开。")]),v._v(" "),t("p",[v._v("LockSupport 使用类似信号量的机制，为每个线程准备了一个许可，如果这个许可可用，park 方法会返回，并把这个许可变为不可用，如果许可不可用，就阻塞线程。unpark 则相反。这个机制使得即使 unpark 方法操作发生在 park 之前，也可以使下一次的 park方法操作立即返回。")]),v._v(" "),t("h3",{attrs:{id:"synchronized-和-lock-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-和-lock-有什么区别"}},[v._v("#")]),v._v(" synchronized 和 Lock 有什么区别？")]),v._v(" "),t("ul",[t("li",[v._v("首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；")]),v._v(" "),t("li",[v._v("synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。")]),v._v(" "),t("li",[v._v("synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。")]),v._v(" "),t("li",[v._v("通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。")])]),v._v(" "),t("h3",{attrs:{id:"synchronized-和-reentrantlock-区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-和-reentrantlock-区别是什么"}},[v._v("#")]),v._v(" synchronized 和 ReentrantLock 区别是什么？")]),v._v(" "),t("p",[t("strong",[v._v("synchronized 是")]),v._v("和 if、else、for、while 一样的"),t("strong",[v._v("关键字")]),v._v("，"),t("strong",[v._v("ReentrantLock 是类")]),v._v("，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量")]),v._v(" "),t("p",[v._v("synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。")]),v._v(" "),t("p",[v._v("相同点："),t("strong",[v._v("两者都是可重入锁")])]),v._v(" "),t("p",[v._v("两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。")]),v._v(" "),t("p",[v._v("主要区别如下：")]),v._v(" "),t("ul",[t("li",[v._v("ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；")]),v._v(" "),t("li",[v._v("ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；")]),v._v(" "),t("li",[v._v("ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、代码块等。")]),v._v(" "),t("li",[v._v("二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word")]),v._v(" "),t("li",[v._v("对比synchronized ,可中断，可设置超时时间，可设置公平锁，支持多个条件变量，避免虚假唤醒")])]),v._v(" "),t("p",[v._v("Java中每一个对象都可以作为锁，这是"),t("strong",[v._v("synchronized")]),v._v("实现同步的基础：")]),v._v(" "),t("ul",[t("li",[v._v("普通同步方法，锁是当前实例对象")]),v._v(" "),t("li",[v._v("静态同步方法，锁是当前类的class对象")]),v._v(" "),t("li",[v._v("同步方法块，锁是括号里面的对象")])]),v._v(" "),t("h2",{attrs:{id:"voliatile原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#voliatile原理"}},[v._v("#")]),v._v(" voliatile原理")]),v._v(" "),t("p",[v._v("底层实现原理是内存屏障，memory barrier(memory fence)")]),v._v(" "),t("p",[v._v("对volatile 变量的写指令后会加入写屏障")]),v._v(" "),t("p",[v._v("对volatile 变量的读指令前会加入读屏障")]),v._v(" "),t("p",[v._v("可见性：")]),v._v(" "),t("p",[v._v("写屏障保证在该屏障之前的，对共享变量的改动，都同步到主存中")]),v._v(" "),t("p",[v._v("都屏障保证在该屏障之后的，对共享变量的读取，加载的都是主存中的最新数据")]),v._v(" "),t("p",[v._v("有序性：")]),v._v(" "),t("p",[v._v("不会把写屏障之前的代码，排在写屏障的后面")]),v._v(" "),t("p",[v._v("不会把都屏障之后的代码，排在读屏障的前面")]),v._v(" "),t("p",[v._v("更底层是读取变量时使用lock指令来保证多核cpu之间的可见性和有序性")]),v._v(" "),t("p",[v._v("happens-before原则")]),v._v(" "),t("p",[v._v("happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是"),t("strong",[v._v("可见性与有序性的一套规则总结")]),v._v("，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见。")]),v._v(" "),t("p",[v._v("● 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见")]),v._v(" "),t("p",[v._v("● 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见")]),v._v(" "),t("p",[v._v("● 线程 start 前对变量的写，对该线程开始后对该变量的读可见")]),v._v(" "),t("p",[v._v("●线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）")]),v._v(" "),t("p",[v._v("●线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）")]),v._v(" "),t("p",[v._v("程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！")]),v._v(" "),t("p",[v._v("管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）")]),v._v(" "),t("p",[v._v("volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。")]),v._v(" "),t("p",[v._v("线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。")]),v._v(" "),t("p",[v._v("线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。")]),v._v(" "),t("p",[v._v("线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。")]),v._v(" "),t("p",[v._v("传递规则：这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。")]),v._v(" "),t("p",[v._v("对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。")]),v._v(" "),t("ol",[t("li",[v._v("规则一：程序的顺序性规则\n一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。")])]),v._v(" "),t("p",[v._v("对于这一点，可能会有疑问。顺序性是指，我们可以按照顺序推演程序的执行结果，但是编译器未必一定会按照这个顺序编译，但是编译器保证结果一定==顺序推演的结果。")]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[v._v("规则二：volatile规则\n对一个volatile变量的写操作，happens-before后续对这个变量的读操作。")])]),v._v(" "),t("li",[t("p",[v._v("规则三：传递性规则\n如果A happens-before B，B happens-before C，那么A happens-before C。")])])]),v._v(" "),t("p",[v._v("jdk1.5的增强就体现在这里。回到上面例子中，线程A中，根据规则一，对变量x的写操作是happens-before对变量v的写操作的，根据规则二，对变量v的写操作是happens-before对变量v的读操作的，最后根据规则三，也就是说，线程A对变量x的写操作，一定happens-before线程B对v的读操作，那么线程B在注释处读到的变量x的值，一定是42.")]),v._v(" "),t("p",[v._v("4.规则四：管程中的锁规则\n对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。")]),v._v(" "),t("p",[v._v("这一点不难理解。")]),v._v(" "),t("p",[v._v("5.规则五：线程start()规则\n主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。也就是start() happens before 线程B中的操作。")]),v._v(" "),t("p",[v._v("6.规则六：线程join()规则\n主线程A等待子线程B完成，当子线程B执行完毕后，主线程A可以看到线程B的所有操作。也就是说，子线程B中的任意操作，happens-before join()的返回。")]),v._v(" "),t("p",[v._v("线程池")]),v._v(" "),t("p",[v._v("newFixedThreadpool")]),v._v(" "),t("p",[v._v("核心=最大，无需超时时间，阻塞队列时无界的，可以放任意数量的任务")]),v._v(" "),t("p",[v._v("适合任务量已知，相对耗时的任务")]),v._v(" "),t("p",[v._v("newCachedThreadPool")]),v._v(" "),t("p",[v._v("核心为0.最大为integer.max，救急线程生存时间60s，全部是救济线程")]),v._v(" "),t("p",[v._v("适合任务数比较密集，但是每个任务执行时间较短的情况")]),v._v(" "),t("h1",{attrs:{id:"aqs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aqs"}},[v._v("#")]),v._v(" AQS")]),v._v(" "),t("p",[t("strong",[v._v("AQS")]),v._v(" "),t("strong",[v._v("原理")])]),v._v(" "),t("p",[t("strong",[v._v("1.")]),v._v(" "),t("strong",[v._v("概述")])]),v._v(" "),t("p",[v._v("全称是 AbstractQueuedSynchronizer ，是阻塞式锁和相关的同步器工具的框架")]),v._v(" "),t("p",[t("strong",[v._v("AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中")])]),v._v(" "),t("p",[v._v("特点：")]),v._v(" "),t("p",[v._v("用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取")]),v._v(" "),t("p",[v._v("锁和释放锁")]),v._v(" "),t("p",[v._v("getState - 获取 state 状态")]),v._v(" "),t("p",[v._v("setState - 设置 state 状态")]),v._v(" "),t("p",[v._v("compareAndSetState - cas 机制设置 state 状态")]),v._v(" "),t("p",[v._v("独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源")]),v._v(" "),t("p",[v._v("提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList")]),v._v(" "),t("p",[v._v("条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet")]),v._v(" "),t("p",[v._v("1.state设计")]),v._v(" "),t("p",[v._v("state使用volatile配合cas保证其修改时的原子性")]),v._v(" "),t("p",[v._v("使用32bit int来维护同步状态")]),v._v(" "),t("p",[v._v("2.阻塞恢复设计")]),v._v(" "),t("p",[v._v("使用park & unpark来实现线程的暂停和恢复，次序不影响")]),v._v(" "),t("p",[v._v("park & unpark 是针对线程的，不针对同步器，控制粒度更加精细")]),v._v(" "),t("p",[v._v("park线程可以通过interrupt打断")]),v._v(" "),t("p",[v._v("3.队列设计")]),v._v(" "),t("p",[v._v("使用FIFO队列，不支持优先级队列。")]),v._v(" "),t("p",[v._v("队列中有head和tail两个指针节点，都用volatile修饰配合cas使用，每个节点有state维护节点状态")]),v._v(" "),t("p",[v._v("入队时只考虑tail赋值的原子性")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200726110603997.png",alt:"img"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200726110622255.png",alt:"img"}})]),v._v(" "),t("h2",{attrs:{id:"concurrenthashmap原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap原理"}},[v._v("#")]),v._v(" ConcurrentHashMap原理")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200726160012597.png",alt:"img"}})])])}),[],!1,null,null,null);_.default=r.exports}}]);